
History:

    The author had an interview with a coding component.  This was
    one of the problems.  The author had a choice of languages, and
    began to ponder which was best.

    At the same time, the author was curious what ChatGPT-4 could
    do in terms of generating code for other languages.  The author
    generated the first code by hand, and used ChatGPT to do initial
    translations to other languages.  About 1/3 of the ChatGPT
    versions worked as-is, while 2/3rds took some minor fixing and
    debugging.  All ChatGPT versions were looked over manually for
    optimizations.  In at least two cases it chose very inefficient
    methods that while working greatly slowed execution, these were
    manually fixed.

    The author is not fluent in all of these languages.  The author
    accepts patches that improve the programs using standard methods
    (e.g. no "special tricks").

Problem statement: 

    Given a list of integers determine if the list can be split at
    any point so that the sum of the items on both sides of the
    split are the same.  Return the left and right parts as new
    lists.

Test cases:

    []  ->  [[], []]
    [100]  ->  [[], []]
    [99, 99]  ->  [[99], [99]]
    [98, 1, 99]  ->  [[98, 1], [99]]
    [99, 1, 98]  ->  [[99], [1, 98]]
    [1, 2, 3, 0]  ->  [[1, 2], [3, 0]]
    [1, 2, 3, 5]  ->  [[], []]
    [1, 2, 2, 1, 0]  ->  [[1, 2], [2, 1, 0]]
    [10, 11, 12, 16, 17]  ->  [[10, 11, 12], [16, 17]]
    [1, 1, 1, 1, 1, 1, 6]  ->  [[1, 1, 1, 1, 1, 1], [6]]
    [6, 1, 1, 1, 1, 1, 1]  ->  [[6], [1, 1, 1, 1, 1, 1]]
    
    Note: The return [[], []] may be null/nill/error in some languages.

How to run:

    'make' will execute all compilation steps (same as 'make all').

    'make runall' will build (if necessary) and then execute tests in all languages.

Language specific notes:

     ZSH and BASH do not support functions returning values.  The
     values are printed to the screen.

     Java requires the file name and class name to match, and the
     class name to not include a '-' character, resulting in the
     file being called splitSum.java.

     Rust needs to be build with cargo to bring in the lazy_static
     dependency.  Cargo requires a particular directory structure,
     so the rust source code is in src/main.rs, the executable is
     output to target/release/split-sum and the Cargo.toml file is
     in the main directory.

     C++, Objective-C, and Swift can all basically use the same
     implementation as C, but instead their OOP data structures
     were used to demonstrate the differences in performance.

     TCL global variables must be before any procedures, so the
     cases variable has been moved to the top of the file.

     ZSH and BASH are both slow enough that 100,000 runs takes too
     long.  The code has been modified to do 10,000 runs, and
     multiply the result by 10.

Arrays:

     There is one language, ZSH, that starts arrays at 1 rather
     than 0.  Don't use ZSH for scripting.

     There appears to be no agreement on how array slices should
     work.

	 Go, Rust, Python 3, PHP, C++, Objective-C, Java and
	 JavaScript all return a list exclusive of the end position.
	 E.g.  Slicing [ 1 2 3 4 5 ] with a start of 1 and an end
	 of 3 results in [ 2 3 ].

	 TCL, Ruby, Swift, Perl 5, PostgreSQL, BASH, and ZSH all
	 return a list inclusive of the end position.  E.g. Slicing
	 [ 1 2 3 4 5 ] with a start of 1 and an end of 3 results
	 in [ 2 3 4 ].

Results:

The runall target runs 100,000 (10,000 for BASH and ZSH, which is
then multiplied by 10 for consistency) iterations of the testCases
function and outputs the time in seconds taken for all runs.

                           Times  Array Slice x:y returns
Rank   Seconds Language    Slower Start entries from          Comment
1       0.074  C           1      0     No slice function.    Built in arrays of i32.
2       0.313  Java        4.2    0     [x]   ... [y-1]       Built in arrays, of int.
3       0.418  Go          5.6    0     [x]   ... [y-1]       Built in arrays i32.
4       0.443  Rust        6.0    0     [x]   ... [y-1]       Box of Box of i32.
5       0.622  JavaScript  8.4    0     [x]   ... [y-1]       Built in arrays, of int.
6       1.935  TCL         26     0     [x]   ... [y]         Built in arrays untyped.
7       1.997  C++         27     0     [x]   ... [y-1]       vector of vector of int.
8       2.635  PHP         35     0     [x]   ... [y-1]       Built in arrays, untyped.
9       2.912  Swift       39     0     [x]   ... [y]         Built in arrays of int.
10      4.404  Objective-C 60     0     [x]   ... [y-1]       NSArray of NSArray of NSNumber.
11      5.040  Ruby        68     0     [x]   ... [y]         Built in arrays, untyped.
12      7.622  Python 3    103    0     [x]   ... [y-1]       Built in arrays, of int.
13     18.680  Perl 5      252    0     [x]   ... [y]         Built in arrays, untyped.
14     30.740  PostgreSQL  415    0     [x]   ... [y]         Built in arrays, of int.
15    990.000  ZSH         13378  1     [x]   ... [y]         Built in arrays, untyped.
16   2350.000  BASH        31756  0     [x]   ... [y]         Built in arrays, untyped.

The file benchmark-run.txt contains the run used to make this table.
